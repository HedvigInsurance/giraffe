type Query {
  insurance: Insurance!
  cashback: Cashback
  cashbackOptions: [Cashback]!
  signStatus: SignStatus
  member: Member!
  gifs(query: String!): [Gif]!
  file(key: String!): File!
  messages: [Message]!
  currentChatResponse: ChatResponse
  chatState: ChatState!
  avatars: [Avatar]
  chatActions: [ChatAction]
}

type Mutation {
  logout: Boolean!
  createSession(campaign: CampaignInput, trackingId: UUID): String!
  createSessionV2: SessionInformation
  createOffer(details: OfferInput!): Boolean
  signOffer(details: SignInput!): Boolean @deprecated(reason: "Use `signOfferV2`.")
  signOfferV2(details: SignInput): BankIdSignResponse!
  uploadFile(file: Upload!): File!
  selectCashbackOption(id: ID!): Cashback!
  offerClosed: Boolean!
  startDirectDebitRegistration: URL!
  sendChatTextResponse(input: ChatResponseTextInput!): Boolean!
  sendChatSingleSelectResponse(input: ChatResponseSingleSelectInput!): Boolean!
  sendChatFileResponse(input: ChatResponseFileInput!): Boolean!
  sendChatAudioResponse(input: ChatResponseAudioInput!): Boolean!
  resetConversation: Boolean!
  editLastResponse: Boolean!
  updateEmail(input: String!): Member!
  updatePhoneNumber(input: String!): Member!
  registerPushToken(pushToken: String!): Boolean
  triggerFreeTextChat: Boolean
  triggerClaimChat(input: TriggerClaimChatInput!): Boolean
  triggerCallMeChat: Boolean
  emailSign: Boolean
  markMessageAsRead(globalId: ID!): Message!
  log(input: LoggingInput!): Boolean
  bankIdAuth: BankIdAuthResponse!
  registerBranchCampaign(campaign: CampaignInput!): Boolean
  updateLanguage(input: String!): Boolean! # input should be in the format as Accept-Language header
}

type Subscription {
  offer: OfferEvent
  signStatus: SignEvent
  message: Message!
  currentChatResponse(mostRecentTimestamp: String!): ChatResponse
  chatState(mostRecentTimestamp: String!): ChatState!
  authStatus: AuthEvent
}

input TriggerClaimChatInput {
  claimTypeId: ID
}

type Message {
  globalId: ID!
  id: ID!
  body: MessageBody!
  header: MessageHeader!
}

type MessageHeader {
  messageId: ID!
  fromMyself: Boolean!
  timeStamp: String!
  richTextChatCompatible: Boolean!
  editAllowed: Boolean!
  shouldRequestPushNotifications: Boolean!
  pollingInterval: Int!
  loadingIndicator: String
  markedAsRead: Boolean!
  statusMessage: String
}

union MessageBody =
    MessageBodySingleSelect
  | MessageBodyMultipleSelect
  | MessageBodyText
  | MessageBodyNumber
  | MessageBodyAudio
  | MessageBodyBankIdCollect
  | MessageBodyFile
  | MessageBodyParagraph
  | MessageBodyUndefined

interface MessageBodyCore {
  type: String!
  id: ID!
  text: String!
}

type MessageBodySingleSelect implements MessageBodyCore {
  type: String!
  id: ID!
  text: String!
  choices: [MessageBodyChoices]
}

type MessageBodyMultipleSelect implements MessageBodyCore {
  type: String!
  id: ID!
  text: String!
  choices: [MessageBodyChoices]
}

type MessageBodyText implements MessageBodyCore {
  type: String!
  id: ID!
  text: String!
  placeholder: String
  keyboard: KeyboardType
  textContentType: TextContentType
}

type MessageBodyNumber implements MessageBodyCore {
  type: String!
  id: ID!
  text: String!
  placeholder: String
  keyboard: KeyboardType
  textContentType: TextContentType
}

enum KeyboardType {
  DEFAULT
  NUMBERPAD
  DECIMALPAD
  NUMERIC
  EMAIL
  PHONE
}

enum TextContentType {
  NONE
  URL
  ADDRESS_CITY
  ADDRESS_CITY_STATE
  ADDRESS_STATE
  COUNTRY_NAME
  CREDIT_CARD_NUMBER
  EMAIL_ADDRESS
  FAMILY_NAME
  FULL_STREET_ADDRESS
  GIVEN_NAME
  JOB_TITLE
  LOCATION
  MIDDLE_NAME
  NAME
  NAME_PREFIX
  NAME_SUFFIX
  NICK_NAME
  ORGANIZATION_NAME
  POSTAL_CODE
  STREET_ADDRESS_LINE1
  STREET_ADDRESS_LINE2
  SUBLOCALITY
  TELEPHONE_NUMBER
  USERNAME
  PASSWORD
}

type MessageBodyAudio implements MessageBodyCore {
  type: String!
  id: ID!
  text: String!
  url: String
}

type MessageBodyBankIdCollect implements MessageBodyCore {
  type: String!
  id: ID!
  text: String!
  referenceId: String
}

type MessageBodyParagraph implements MessageBodyCore {
  type: String!
  id: ID!
  text: String!
}

type MessageBodyFile implements MessageBodyCore {
  type: String!
  id: ID!
  text: String!
  key: String
  mimeType: String

  file: File!
}

type MessageBodyUndefined implements MessageBodyCore {
  type: String!
  id: ID!
  text: String!
}

union MessageBodyChoices =
    MessageBodyChoicesUndefined
  | MessageBodyChoicesSelection
  | MessageBodyChoicesLink

interface MessageBodyChoicesCore {
  type: String!
  value: String!
  text: String!
  selected: Boolean!
}

type MessageBodyChoicesUndefined implements MessageBodyChoicesCore {
  type: String!
  value: String!
  text: String!
  selected: Boolean!
}

type MessageBodyChoicesSelection implements MessageBodyChoicesCore {
  type: String!
  value: String!
  text: String!
  selected: Boolean!
  clearable: Boolean
}

enum MessageBodyChoicesLinkView {
  OFFER
  DASHBOARD
}

type MessageBodyChoicesLink implements MessageBodyChoicesCore {
  type: String!
  value: String!
  text: String!
  selected: Boolean!
  view: MessageBodyChoicesLinkView
  appUrl: String
  webUrl: String
}

type ChatState {
  ongoingClaim: Boolean!
  showOfferScreen: Boolean!
  onboardingDone: Boolean!
}

type ChatResponse {
  globalId: ID!
  id: ID!
  body: MessageBody!
  header: MessageHeader!
}

input ChatResponseBodyTextInput {
  text: String!
}

input ChatResponseTextInput {
  globalId: ID!
  body: ChatResponseBodyTextInput!
}

input ChatResponseBodySingleSelectInput {
  selectedValue: ID!
}

input ChatResponseSingleSelectInput {
  globalId: ID!
  body: ChatResponseBodySingleSelectInput!
}

input ChatResponseBodyFileInput {
  key: String!
  mimeType: String!
}

input ChatResponseFileInput {
  globalId: ID!
  body: ChatResponseBodyFileInput!
}

input ChatResponseBodyAudioInput {
  url: String!
}

input ChatResponseAudioInput {
  globalId: ID!
  file: Upload!
}

input CampaignInput {
  source: String
  medium: String
  term: String
  content: String
  name: String
}

enum LoggingSource {
  IOS
  ANDROID
}

enum LoggingSeverity {
  DEFAULT
  DEBUG
  INFO
  NOTICE
  WARNING
  ERROR
  CRITICAL
  ALERT
  EMERGENCY
}

scalar JSONObject
scalar TimeStamp

input LoggingInput {
  timestamp: TimeStamp!
  source: LoggingSource!
  payload: JSONObject!
  severity: LoggingSeverity!
}

type Avatar {
  name: String!
  URL: String!
  width: Int!
  height: Int!
  duration: Int!
  data: Object
}

type Gif {
  url: String
}

type SessionInformation {
  token: String!
  memberId: String!
}

type OfferEvent {
  status: OfferStatus!
  insurance: Insurance
}

type SignEvent {
  status: SignStatus
}

type AuthEvent {
  status: AuthState
}

enum OfferStatus {
  SUCCESS
  FAIL
}

input OfferInput {
  firstName: String!
  lastName: String!
  age: Int!
  address: String!
  postalNumber: String!
  city: String
  insuranceType: InsuranceType!
  squareMeters: Int!
  personsInHousehold: Int!
  previousInsurer: String
}

input SignInput {
  personalNumber: String!
  email: String!
}

type Insurance {
  address: String
  postalNumber: String
  cost: InsuranceCost
  personsInHousehold: Int
  certificateUrl: String
  status: InsuranceStatus!
  type: InsuranceType
  activeFrom: LocalDate
  insuredAtOtherCompany: Boolean @deprecated(
    reason: "Use previousInsurer instead"
  )
  presaleInformationUrl: String
  policyUrl: String
  currentInsurerName: String @deprecated(
    reason: "Use previousInsurer instead"
  )
  livingSpace: Int
  perilCategories: [PerilCategory] @deprecated(
    reason: "Use arrangedPerilCategories instead"
  )
  monthlyCost: Int @deprecated(
    reason: "Use cost instead"
  )
  safetyIncreasers: [String!] @deprecated(
    reason: "No longer supported"
  )
  arrangedPerilCategories: ArrangedPerilCategories!
  renewal: Renewal
  previousInsurer: PreviousInsurer
  ancillaryArea: Int
  yearOfConstruction: Int
  numberOfBathrooms: Int
  extraBuildings: [ExtraBuilding!]
  isSubleted: Boolean
}

union ExtraBuilding =
    ExtraBuildingGarage
  | ExtraBuildingCarport
  | ExtraBuildingShed
  | ExtraBuildingStorehouse
  | ExtraBuildingFriggebod
  | ExtraBuildingAttefall
  | ExtraBuildingOuthouse
  | ExtraBuildingGuesthouse
  | ExtraBuildingGazebo
  | ExtraBuildingGreenhouse
  | ExtraBuildingSauna
  | ExtraBuildingBarn
  | ExtraBuildingBoathouse
  | ExtraBuildingOther

interface ExtraBuildingCore {
  area: Int!
  displayName: String!
  hasWaterConnected: Boolean!
}

type ExtraBuildingGarage implements ExtraBuildingCore {
  area: Int!
  displayName: String!
  hasWaterConnected: Boolean!
}

type ExtraBuildingCarport implements ExtraBuildingCore {
  area: Int!
  displayName: String!
  hasWaterConnected: Boolean!
}

type ExtraBuildingShed implements ExtraBuildingCore {
  area: Int!
  displayName: String!
  hasWaterConnected: Boolean!
}

type ExtraBuildingStorehouse implements ExtraBuildingCore {
  area: Int!
  displayName: String!
  hasWaterConnected: Boolean!
}

type ExtraBuildingFriggebod implements ExtraBuildingCore {
  area: Int!
  displayName: String!
  hasWaterConnected: Boolean!
}

type ExtraBuildingAttefall implements ExtraBuildingCore {
  area: Int!
  displayName: String!
  hasWaterConnected: Boolean!
}

type ExtraBuildingOuthouse implements ExtraBuildingCore {
  area: Int!
  displayName: String!
  hasWaterConnected: Boolean!
}

type ExtraBuildingGuesthouse implements ExtraBuildingCore {
  area: Int!
  displayName: String!
  hasWaterConnected: Boolean!
}

type ExtraBuildingGazebo implements ExtraBuildingCore {
  area: Int!
  displayName: String!
  hasWaterConnected: Boolean!
}

type ExtraBuildingGreenhouse implements ExtraBuildingCore {
  area: Int!
  displayName: String!
  hasWaterConnected: Boolean!
}

type ExtraBuildingSauna implements ExtraBuildingCore {
  area: Int!
  displayName: String!
  hasWaterConnected: Boolean!
}

type ExtraBuildingBarn implements ExtraBuildingCore {
  area: Int!
  displayName: String!
  hasWaterConnected: Boolean!
}

type ExtraBuildingBoathouse implements ExtraBuildingCore {
  area: Int!
  displayName: String!
  hasWaterConnected: Boolean!
}

type ExtraBuildingOther implements ExtraBuildingCore {
  area: Int!
  displayName: String!
  hasWaterConnected: Boolean!
}

type PreviousInsurer {
  displayName: String
  id: ID!
  switchable: Boolean!
}

type Renewal {
  certificateUrl: String!
  date: LocalDate!
}

type ArrangedPerilCategories {
  me: PerilCategory
  home: PerilCategory
  stuff: PerilCategory
}

type Member {
  id: ID
  firstName: String
  lastName: String
  email: String
  phoneNumber: String
  acceptLanguage: String
}

type PerilCategory {
  title: String
  description: String
  iconUrl: String
  perils: [Peril]
}

type Peril {
  id: ID
  title: String
  imageUrl: String
  description: String
}

enum InsuranceStatus {
  PENDING
  ACTIVE
  INACTIVE
  INACTIVE_WITH_START_DATE
  TERMINATED
}

enum InsuranceType {
  RENT
  BRF
  STUDENT_RENT
  STUDENT_BRF
  HOUSE
}

type Cashback {
  id: ID
  name: String
  imageUrl: String
  selectedUrl: String
  description: String
  title: String
  paragraph: String
}

type SignStatus {
  collectStatus: CollectStatus
  signState: SignState
}

type CollectStatus {
  status: BankIdStatus
  code: String
}

type ChatAction {
  text: String
  triggerUrl: URL
  enabled: Boolean
}

type InsuranceCost {
  monthlyGross: MonetaryAmountV2!,
  monthlyDiscount: MonetaryAmountV2!,
  monthlyNet: MonetaryAmountV2!
  freeUntil: LocalDate
}

type MonetaryAmountV2 {
  amount: String!,
  currency: String!
}

type BankIdAuthResponse {
  autoStartToken: String!
}

type BankIdSignResponse {
  autoStartToken: String!
}

enum BankIdStatus {
  pending
  failed
  complete
}

enum SignState {
  INITIATED
  IN_PROGRESS
  FAILED
  COMPLETED
}

enum AuthState {
  INITIATED
  IN_PROGRESS
  FAILED
  SUCCESS
}

scalar LocalDate
scalar Upload
# String-represented URL.
scalar URL
# String-represented UUID.
scalar UUID
scalar Object

type File {
  """
  signedUrl is valid for 30 minutes after upload, don't hang on to this.
  """
  signedUrl: String!
  """
  S3 key that can be used to retreive new signed urls in the future.
  """
  key: String!
}
