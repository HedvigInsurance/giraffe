type Mutation {
    createQuote(input: QuoteInput!): QuoteResult!
}

input QuoteInput {
    firstName: PotentiallyMaskedInput!
    lastName: PotentiallyMaskedInput!
    currentInsurer: String
    personalNumber: String!
    apartment: ApartmentInput
    house: HouseInput
}

input ApartmentInput {
    streetAddress: PotentiallyMaskedInput!
    postalNumber: PotentiallyMaskedInput!
    city: PotentiallyMaskedInput!
    inhabitants: Int!
    livingSpace: Int!
    type: ApartmentType!
}

input HouseInput {
    streetAddress: PotentiallyMaskedInput!
    postalNumber: PotentiallyMaskedInput!
    city: PotentiallyMaskedInput!
    inhabitants: Int!
    livingSpace: Int!
    ancillarySpace: Int!
    extraBuildings: [ExtraBuildingInput!]! # Empty list represents no additional buildings. Hence null is not allowed.
}

input ExtraBuildingInput {
    type: ExtraBuildingType!
    area: Int!
    hasWaterConnected: Boolean!
}

enum ExtraBuildingType {
    GARAGE
    CARPORT
    SHED
    STOREHOUSE
    FRIGGEBOD
    ATTEFALL
    OUTHOUSE
    GUESTHOUSE
    GAZEBO
    GREENHOUSE
    SAUNA
    BARN
    BOATHOUSE
    OTHER
}

enum ApartmentType {
    STUDENT_RENT
    RENT
    STUDENT_BRF
    BRF
}

union QuoteResult = Quote | UnderwritingLimitsHit

type Quote {
    id: ID!
    price: MonetaryAmountV2!
    details: QuoteDetails!
}

union QuoteDetails = ApartmentQuoteDetails |Â HouseQuoteDetails

type ApartmentQuoteDetails {
    streetAddress: String!
    postalNumber: String!
    city: String!
    inhabitants: Int!
    livingSpace: Int!
    type: ApartmentType!
}

type HouseQuoteDetails {
    streetAddress: String!
    postalNumber: String!
    city: String!
    inhabitants: Int!
    livingSpace: Int!
    ancillarySpace: Int!
    extraBuildings: [ExtraBuilding!]!
}

type ExtraBuilding {
    type: ExtraBuildingType!
    area: Int!
    hasWaterConnected: Boolean!
}

type UnderwritingLimitsHit {
    limits: [UnderwritingLimit!]!
}

type UnderwritingLimit {
    id: ID! # Necessary? Not sure
    description: String!
}
